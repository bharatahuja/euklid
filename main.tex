\documentclass[â€¢]{beamer}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{graphicx}

\renewcommand{\tabcolsep}{1.2cm}

\title{Euklidischer Algorithmus}
\subtitle{Proseminar ``Algorithms Unplugged''\\
Wintersemester 2014/15\\ 
Leibniz Universit\"at Hannover}
\date{1. Dezember 2014}
\author{Bharat Ahuja}

\setbeamertemplate{navigation symbols}{}
\defbeamertemplate{footline}{centered page number}
{%
  \hspace*{\fill}%
  \hspace{2em}%
  {\scriptsize \insertpagenumber}%
  \hspace*{\fill}\vskip2pt%
  \vspace{10pt}
}
\setbeamercolor{footline}{fg=blue}
\setbeamerfont{footline}{series=\bfseries}
\setbeamertemplate{footline}[centered page number]
\setbeamersize{text margin left=32pt,text margin right=32pt}
\setbeamertemplate{headline}{\vspace{5pt}}

\begin{document}

\maketitle

%\begin{frame}
%	\frametitle{Inhalte}
%	\tableofcontents
%\end{frame}

\begin{frame}
	\frametitle{Problem 1: Software Projekt}
	\framesubtitle{Bestimmung der Anzahl von Teams}
	
	\begin{figure}
	\centering
	\includegraphics[scale=0.20]{Organisation}
	\caption*{\scriptsize{Quelle: SE-Webseite (Stand 21. Oktober 2014)}}
	\end{figure}
	
\end{frame}
	
	
\begin{frame}
	\frametitle{Software Projekt}
	\framesubtitle{Die Problemstellung}
	\begin{itemize}
		\item 60 Inf., 24 Math., 24 Tech. Inf.
		\item Alle Teams sind gleich gro{\ss}.
		\item Alle Studenten m\"ussen einem Team zugeordnet sein.
		\item Gleichm\"a{\ss}ige Verteilung der Studieng\"ange in jedem Team.
		\item M\"oglichst gro{\ss}e Anzahl von Teams.
		\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Software Projekt}
%	\framesubtitle{Der 1. Schritt zur L\"osung}
	Sei $n \in \mathbb{N}$ die Anzahl der Teams.
	\begin{align*}
	\Rightarrow n|60 \text{, } n|24 \text{ und } n|24 \tag{i}\\
	\end{align*}
	Wir suchen nach der gr\"o{\ss}ten Zahl $n$, die $(i)$ erf\"ullt.
	
	\begin{align*}
	\Rightarrow n = \textit{ggT}(60,24,24) = 12 \text{ Teams}\\
	\end{align*}
	
\end{frame}

\begin{frame}
	\frametitle{Software Projekt}
	\framesubtitle{L\"osungsanalyse}
	Es gibt 12 Teams mit jeweils  --\\
	\begin{itemize}
	\item 9 Studenten
	\item 5 Informatik Studenten
	\item 2 Mathematik Studenten
	\item 2 Technische-Informatik Studenten
	\end{itemize}
\end{frame}

\begin{frame}
    \begin{figure}
	\centering
	\includegraphics[scale=0.4]{cicada}
	\caption*{\scriptsize{Quelle: Wikipedia (Stand 21. Oktober 2014)}}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{Problem 2: Periodische Zikaden}
    \framesubtitle{Nat\"urliche Selektion}
    \begin{itemize}
    \item Zikaden treten alle 13 oder 17 Jahre in Massen auf.
    \item Ihre Feinde leben in 2-, 4- oder 6-Jahres-Rhythmen
    \item So k\"onnen sie den meisten Raubtieren ausweichen.
    \item So kann man auch sp\"ater Arbeit ausweichen.
    \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Periodische Zikaden}
	\framesubtitle{\"Uberlebensstrategie}
\begin{itemize}
\item $\textit{ggT}(4,13) = 1$
\item Teilerfremdheit durch Vergleich der Primfaktoren.
\item Die Zikaden berechnen schnell den \textit{g.g.T.}, ohne Zahlen zu faktorisieren.
\item Abstrakter: Man will schnell Zahlen auf Teilerfremdheit pr\"ufen k\"onnen.
\end{itemize}
%Die Bestimmung der Primfaktorzerlegung einer Zahl liegt aber in NP.
\end{frame}

\begin{frame}
\frametitle{Von der Problemstellung abstrahieren}
\begin{quote}
		Wie kann man den \textit{g.g.T.} schnell bestimmen?
	\end{quote}
	\begin{itemize}
	\item Euklidischer Algorithmus
	\item Binary GCD Algorithm von Stein
	\item GCD Algorithm von Lehmer
	\end{itemize}
\end{frame}

\section{Einf\"uhrung}

\begin{frame}       
	\frametitle{Euklidischer Algorithmus}
    \framesubtitle{Historische Entwicklung}
    \begin{itemize}
    \item  ca. 300 \textit{v.Chr.} in \textit{Buch VII -- Die Elemente} vorgestellt.
    \item Wahrscheinlich nicht selbst erfunden.
    \item Als geometrischen Algorithmus vorgestellt. St\"abe zerlegt.
    \end{itemize}
\end{frame}

\section{Vorstellung der Algorithmen}
\begin{frame}
	\frametitle{Vorstellung der Algorithmen}
	Wir befassen uns mit zwei bekannten Varianten des euklidischen Algorithmus --
	
	\begin{itemize}
	\item \textsc{LangsamEuklid}
	\item \textsc{Euklid}
	\end{itemize}
\end{frame}

%Code
%Flow Chart
%Beispiel
%Korrektheit
%Finiteness

\subsection{\textsc{LangsamEuklid}}
\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\underline{\textsc{LangsamEuklid}}
	\begin{algorithmic}[1]
\While {$a\neq b$}
	\State Falls $a$ gr\"o{\ss}er ist als $b, a\gets a-b$
	\State Falls $b$ gr\"o{\ss}er ist als $a, b\gets b-a$
\EndWhile
	\State Gib den gemeinsamen Wert der Zahlen aus
\end{algorithmic}
\end{frame}

\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\begin{figure}
	\centering
	\begin{tikzpicture}

	\draw [thick, ->] (0.3, 2) -- (0.3, 1);
	\draw (0,1) -- (0,0) -- (2,0) -- (2,1) -- (0,1);
	\node at (1, 0.5) {\scriptsize{$a=b?$}};
	
	\draw [->] (2,0.5) -- (4,0.5);
	\node [above] at (3, 0.5) {\scriptsize{Nein}};
	
	\draw (4,1) -- (4,0) -- (6,0) -- (6,1) -- (4,1);
	\node at (5, 0.5) {\scriptsize{Subtraktion}};
	
	\draw (6, 0.5) -- (7, 0.5) -- (7, 2) -- (1, 2);	
	\draw [->] (1,2) -- (1,1);
	
	\node [above] at (-0.75,0.5) {\scriptsize{Ja}};
	\draw (0,0.5) -- (-1.5,0.5);
	\draw [->] (-1.5,0.5) -- (-1.5, -1);

	\draw (-3,-1) -- (-3, -2) -- (-1, -2) -- (-1, -1) -- (-3,-1);
	\draw (-2.9,-1.1) -- (-2.9, -1.9) -- (-1.1, -1.9) -- (-1.1, -1.1) -- (-2.9,-1.1);
	\node at (-2, -1.5) {\scriptsize{return $a$}};
	\end{tikzpicture}
	\caption{Flussdiagramm \textsc{LangsamEuklid}}
	\end{figure}
\end{frame}
\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Beispiel}
	Betrachte das folgende Beispiel mit $a=24, b=9$:\\
	\vspace{5pt}
	\begin{tabular}{|c|c|c|} \hline
	Iteration Nr.& a & b \\ \hline
	 & 24 & 9 \\ \hline
	1 & 15 & 9 \\ \hline
	2 & 6 & 9 \\ \hline
	3 & 6 & 3 \\ \hline
	4 & \textbf{3} & \textbf{3} \\ \hline \hline
	\end{tabular}\\ \vspace{5pt}
	$\therefore$ der \textit{g.g.T.} von 24 und 9 ist 3.
\end{frame}

\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Endlichkeit}
	\begin{itemize}
	\item Die Zahlen bleiben positiv und ganzzahlig beim Subtraktionsschritt.
	\item Einer der beiden Variablen wird in jeder Iteration um mindestens 1 
verringert.
	\item D.h. der Algorithmus terminiert nach maximal $a+b$ Schritten.
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Korrektheit}
	\begin{itemize}
	\item Die Menge der gemeinsamen Teiler von $a$ und $b$ ist gleich der Menge der gemeinsamen Teiler von $a-b$ und $b$.\\
	 $\therefore$ \textit{g.g.T.}$(a,b)$ = \textit{g.g.T.}$(a-b,b)$
	\item Eine Iteration des Algorithmus \"andert die L\"osung nicht.
	\item \textit{g.g.T.}$(a,a)$ = $a$
	\end{itemize}
\qed
\end{frame}
\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Verbesserungsvorschl\"age}
	\begin{itemize}
	\item $(1069,2) \rightarrow (1067,2) \rightarrow \dots (3,2) \rightarrow (1,2) \rightarrow (1,1)$
	\item In den meisten Iterationen braucht man nicht \"uberpr\"ufen welche der beiden Zahlen gr\"o{\ss}er ist.
	\end{itemize}
\end{frame}

\subsection{\textsc{Euklid}}
\begin{frame}
	\frametitle{\textsc{Euklid}}

\underline{\textsc{Euklid}}
	\begin{algorithmic}[1]
		\State \textbf{if} $a < b$: vertausche a und b.
		\While {$b>0$}
		\State berechne $q,r$ mit $a=q\cdot b+r$, wobei $0\leq r < b$
		\State $a\gets b, b\gets r$
		\EndWhile
		\State \textbf{return} $a$
	\end{algorithmic}	
	
\end{frame}
\begin{frame}
	\frametitle{\textsc{Euklid}}

	\begin{figure}
	\centering
	\begin{tikzpicture}
\draw [thick, ->] (1,2.5) -- (1,1.5);
\draw (0,1.5) -- (0,0) -- (2,0) -- (2,1.5) -- (0,1.5);
\node  [above] at (1,0.75) {\tiny{if $a< b$}};
\node  [below] at (1,0.75) {\tiny{dann vertauschen}};

\draw [->](2,0.75) -- (4,0.75);

\draw (4,1.25) -- (4,0.25) -- (6,0.25) -- (6,1.25) -- (4,1.25);
\node at (5,0.75) {\tiny{$b>0?$}};

\draw [->] (6,0.75) -- (8,0.75);

\node [above] at (7,0.75) {\tiny{Ja}};

\draw (8,1.5) -- (8,0) -- (10,0) -- (10,1.5) -- (8,1.5);
\node at (9,1.15) {\tiny{$a=q\cdot b+r$}};
\node at (9,0.75) {\tiny{$0 \leq r < b$}};
\node at (9,0.35) {\tiny{$a\gets b, b\gets r$}};

\draw (9,0) -- (9,-1) -- (5,-1);
\draw [->] (5,-1) -- (5,0.25);

\draw (5,1.25) -- (5,3);
\draw [->] (5,3) -- (8,3);
\node [right] at (5,2) {\tiny{Nein}};

\draw (8,3.5) -- (8,2.25) -- (10,2.25) -- (10,3.5) -- (8,3.5);
\draw (8.1,3.4) -- (8.1,2.35) -- (9.9,2.35) -- (9.9,3.4) -- (8.1,3.4);
\node at (9,2.875) {\tiny{return $a$}};

\end{tikzpicture}
\caption{Flussdiagramm \textsc{Euklid}}
\end{figure}
\end{frame}

\section{Laufzeitanalyse}

\begin{frame}
	\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid vs. LangsamEuklid}}
	Sei ohne Einschr\"ankung $a>b$.\\ Im ersten Durchlauf gilt --
	
	\begin{equation}a = q \cdot b + r \text{, mit } r < b
	\end{equation}
	 Au{\ss}erdem gilt -- \\ \begin{equation}a \geq b + r\text{, denn }q \geq 1\end{equation} \\
	 Aus $(1), (2)$ folgt\footnote{denn $a \geq b + r > r + r = 2r$} $$r < \frac{a}{2}$$ \\
\end{frame}	
\begin{frame}
	\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid vs. LangsamEuklid}}
	Wegen der Reduktion\footnote{$a \gets b, b \gets r$} sind die Variablen $a,b$ nach 2 Iterationen beide h\"ochstens halb so gro{\ss} wie der \underline{Anfangswert} von $a$. \\ \vspace{15pt}
	Durch Induktion sind nach $2 \cdot k$ Iterationen die beiden Variablen h\"ochstens so gro{\ss} wie $\cfrac{a}{2^k}$ .\\ \vspace{15pt}
	Wenn $k > \log_{2}a$, dann sind beide Variablen null. Aber der Algorithmus muss schon vorher terminieren, wenn $b=0$.\\ \vspace{10pt} Von daher ist $2 \cdot \log_{2}a$ eine obere Schranke f\"ur die Anzahl der Durchl\"aufe, die viel besser als $a+b$ ist.
\end{frame}

\begin{frame}
	\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid}}
	\begin{itemize}
	\item Sei $T_{b}$ die durchschnittliche Anzahl an Iterationen des euklidischen Algorithmus, wenn der Parameter $b$ festliegt \"uber alle $a \in \mathbb{N}$.
	\item Nach der ersten Iteration ist immer nur der Divisionsrest relevant. Deswegen m\"usste $T_{b}$ f\"ur alle $b \in \mathbb{N}$ existieren und l\"asst sich als Durchschnitt \"uber die Anzahl an Iterationen bei $a=1, a=2, \dots ,a=b$ berechnen.\footnote{\scriptsize{Ohne die Zahlen vorher zu vertauschen nat\"urlich!}}
	$$\therefore T_{b} = \frac{1}{b} \sum_{0 < k\leq b} T(k,b)$$
	\end{itemize}
	\end{frame}

\begin{frame}	
		\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid} : Beispiel $T_5$}
	
	$T_5 = \frac{(T(1,5) + T(2,5) \dots T(5,5))}{5}$\\
	Zum Beispiel $T(2,5) = 3$, denn
	\setcounter{equation}{0}
	\begin{align}
	2&=0\cdot 5 + 1	\\
	5&=2\cdot 2 + 1 \\
	2&= 2\cdot 1+0
	\end{align}
		Im Durchschnitt muss man 2.6 Iterationen ausf\"uhren wenn man eine nat\"urliche Zahl auf Teilerfremdheit mit 5 \"uberpr\"ufen will, denn $T_5 = \frac{2+3+4+3+1}{5} = 2.6$.
	\end{frame}

	\begin{frame}	
		\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid} : Absch\"atzung von $T_b$}
	F\"ur gro{\ss}e $b \in \mathbb{N}$ gilt
	$$T_b \approx 1 + \frac{1}{b} (T_0 + T_1 \dots T_{b-1})$$ da nach der ersten Iteration von $T(k,b)$ ungef\"ahr $T_{k}$ Iterationen noch bleiben.\footnote{\scriptsize{Hier hat man also $b$ durch eine zuf\"allige Zahl modulo $k$ gesch\"atzt.}}\\
	\begin{align*}
	k&=0\cdot b + k\\
	b&=q_{2}\cdot k + r_2\\
	&\vdots
\end{align*}		
	 $ \text{D.h. }T_b \approx S_b \text{, wobei }$ $$S_0 := 0, S_n := 1 + \frac{1}{n} (S_0 + S_1 \dots + S_{n-1})$$
\end{frame}		

\begin{frame}
\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid}}
Die Rekursion l\"asst sich folgenderweise l\"osen.
	\begin{align*}
	S_{n+1} &= 1 + \frac{1}{n+1}(S_0 + S_1 \dots + S_n)\\
	&= 1 + \frac{1}{n+1}(n(S_n - 1) + S_n)\\
	&= S_n + \frac{1}{n+1}
	\end{align*}
	$\Rightarrow S_n = H_n = 1 + \frac{1}{2} + \dots \frac{1}{n} \Rightarrow T_b \approx \ln b + O(1)$ \\
	Aus der Praxis hat sich ergeben, dass diese Sch\"atzung von $T_b$ eher pessimistisch ist, und dass diese Funktion etwas langsamer w\"achst.
\end{frame}
	
	\begin{frame}
	\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid}}
	\begin{itemize}
	\item Sei umgekehrt $U_{a}$ die durchschnittliche Anzahl an Iterationen des euklidischen Algorithmus, wenn der Parameter $a$ festliegt \"uber alle $b \in \mathbb{N}$.
	\item Dann gilt $b \leq a$ nur in endlich vielen F\"allen. Ansonsten werden immer die Zahlen in der ersten Iteration getauscht. Danach ist die Anzahl der Iterationen identisch wie oben. Dann muss $U_a = T_a + 1$ gelten.
	\end{itemize}
	\end{frame}
	
	\begin{frame}
	\frametitle{Laufzeitanalyse}
	\framesubtitle{\textsc{Euklid}}

	Betrachte die Fibonacci-Zahlen --
	\begin{align*}
 f_{n+1} &= 1 \cdot f_{n} + f_{n-1} \\
 f_{n} &= 1 \cdot f_{n-1} + f_{n-2} \\
 &\vdots \\
 f_{2} &= 1 \cdot f_{1} + 0 \\
 f_{1} &= 1
\end{align*}
Im Euklidischen Algorithmus werden die Reste umso schneller klein, je gr\"o{\ss}er die Quotienten sind. Im Fall der Fibonacci Zahlen, nehmen die Quotienten alle den kleinstm\"oglichen Wert an. \\Deswegen ist dieser der ung\"unstigste Fall.
\end{frame}	

\end{document}

