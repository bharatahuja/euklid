\documentclass[â€¢]{beamer}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{amssymb}

\renewcommand{\tabcolsep}{1.2cm}

\title{Euklidischer Algorithmus}
\subtitle{Proseminar ``Algorithms Unplugged''\\
Wintersemester 2014/15\\ 
Leibniz Universit\"at Hannover}
\date{1. Dezember 2014}
\author{Bharat Ahuja}

\setbeamertemplate{navigation symbols}{}
\defbeamertemplate{footline}{centered page number}
{%
  \hspace*{\fill}%
  \hspace{2em}%
  {\tiny \insertpagenumber}%
  \hspace*{\fill}\vskip2pt%
  \vspace{10pt}
}
\setbeamercolor{footline}{fg=blue}
\setbeamerfont{footline}{series=\bfseries}
\setbeamertemplate{footline}[centered page number]
\setbeamersize{text margin left=32pt,text margin right=32pt}
\setbeamertemplate{headline}{\vspace{5pt}}

\begin{document}

\maketitle

\begin{frame}
	\frametitle{Inhalte}
	\tableofcontents[]
\end{frame}

\section{Einf\"uhrung}
\begin{frame}
	\frametitle{Einf\"uhrung}
    \framesubtitle{Was ist der Euklidische Algorithmus?}
    \begin{quote}
    Der euklidische Algorithmus ist ein Algorithmus, mit dem sich der 		\underline{gr\"o{\ss}te gemeinsame Teiler} (\textit{g.g.T.}) 			zweier nat\"urlicher\footnote{$\mathbb{N} =  \left\{ 1,2,3\dots \right\}$} Zahlen berechnen l\"asst. 
    
    \end{quote} 
\end{frame}

\begin{frame}       
	\frametitle{Einf\"uhrung}
    \framesubtitle{Historische Entwicklung}
    Diesen Algorithmus hat Euklid ca. 300 \textit{v.Chr.} in 				\textit{Buch VII -- Die Elemente} (Proposition 1 und 2) als einen 		geometrischen Algorithmus vorgestellt. 
    
    Euklid hat sp\"ater den Algorithmus erweitert, so dass man den 			\textit{g.g.T.} reeller Zahlen berechnen kann. Allerdings 				terminiert dieser erweiterte Algorithmus nicht f\"ur alle 				Eingaben.
    \end{frame}

\begin{frame}
	\frametitle{Einf\"uhrung}
    \framesubtitle{Anwendung/Relevanz}
    Der gr\"o{\ss}te Vorteil des Algorithmus ist das leichte \underline{Pr\"ufen auf Teilerfremdheit zweier Zahlen}. \\ Die Teilerfremdheit zweier Zahlen kann man alternativ durch das Vergleichen der Primfaktoren \"uberpr\"ufen. Die Bestimmung der Primfaktorzerlegung einer Zahl liegt aber in NP. \\ Andererseits l\"asst uns dieser Algorithmus schnell den \textit{g.g.T.} berechnen, ohne diese Zahlen faktorisieren zu m\"ussen. Ist der \textit{g.g.T.} gleich 1, dann sind die Zahlen teilerfremd.
    
\end{frame}

\section{Vorstellung der Algorithmen}
\begin{frame}
	\frametitle{Vorstellung der Algorithmen}
	Wir befassen uns mit zwei bekannten Varianten des euklidischen Algorithmus --
	
	\begin{itemize}
	\item \textsc{LangsamEuklid}
	\item \textsc{Euklid}
	\end{itemize}
\end{frame}

%Code
%Flow Chart
%Beispiel
%Korrektheit
%Finiteness

\subsection{\textsc{LangsamEuklid}}
\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	So hat Euklid den Algorithmus zuerst vorgestellt. Sein Algorithmus hat St\"abe zerlegt statt Zahlen zu subtrahieren.\\
	\vspace{3pt}
	\underline{\textsc{LangsamEuklid}}
	\begin{algorithmic}[1]
\While {$a\neq b$}
	\State Falls $a$ gr\"o{\ss}er ist als $b, a\gets a-b$
	\State Falls $b$ gr\"o{\ss}er ist als $a, b\gets b-a$
\EndWhile
	\State Gib den gemeinsamen Wert der Zahlen aus
\end{algorithmic}
\end{frame}

\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\begin{figure}
	\centering
	\begin{tikzpicture}

	\draw [thick, ->] (0.3, 2) -- (0.3, 1);
	\draw (0,1) -- (0,0) -- (2,0) -- (2,1) -- (0,1);
	\node at (1, 0.5) {\scriptsize{$a=b?$}};
	
	\draw [->] (2,0.5) -- (4,0.5);
	\node [above] at (3, 0.5) {\scriptsize{Nein}};
	
	\draw (4,1) -- (4,0) -- (6,0) -- (6,1) -- (4,1);
	\node at (5, 0.5) {\scriptsize{Subtraktion}};
	
	\draw (6, 0.5) -- (7, 0.5) -- (7, 2) -- (1, 2);	
	\draw [->] (1,2) -- (1,1);
	
	\node [above] at (-0.75,0.5) {\scriptsize{Ja}};
	\draw (0,0.5) -- (-1.5,0.5);
	\draw [->] (-1.5,0.5) -- (-1.5, -1);

	\draw (-3,-1) -- (-3, -2) -- (-1, -2) -- (-1, -1) -- (-3,-1);
	\draw (-2.9,-1.1) -- (-2.9, -1.9) -- (-1.1, -1.9) -- (-1.1, -1.1) -- (-2.9,-1.1);
	\node at (-2, -1.5) {\scriptsize{return $a$}};
	\end{tikzpicture}
	\caption{Flussdiagramm \textsc{LangsamEuklid}}
	\end{figure}
\end{frame}
\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Beispiel}
	Betrachte das folgende Beispiel mit $a=24, b=9$:\\
	\vspace{5pt}
	\begin{tabular}{|c|c|c|} \hline
	Schritt Nr.& a & b \\ \hline
	 & 24 & 9 \\ \hline
	1 & 15 & 9 \\ \hline
	2 & 6 & 9 \\ \hline
	3 & 6 & 3 \\ \hline
	4 & \textbf{3} & \textbf{3} \\ \hline \hline
	\end{tabular}\\ \vspace{5pt}
	$\therefore$ der \textit{g.g.T.} von 24 und 9 ist 3.
\end{frame}

\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Endlichkeit}
	Die Zahlen bleiben nat\"urlich beim Subtraktionsschritt, da man immer eine kleinere Zahl von einer gr\"o{\ss}eren Zahl abzieht. Insbesondere sind die beiden Zahlen mindestens 1.
	\\Weil einer der beiden Variablen in jeder Iteration um mindestens 1 verringert wird, terminiert der Algorithmus nach maximal $a+b$ Schritten.
\end{frame}

\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Korrektheit}
	Ohne Einschr\"ankung sei $a>b$. Dann gelten --
	\begin{enumerate}
		\item $\forall t \in \mathbb{N}:t|a , t|b \Rightarrow t|(a-b)$
		\item $\forall t \in \mathbb{N}:t|(a-b) , t|b \Rightarrow t|a$
	\end{enumerate}
	D.h. die Menge der gemeinsamen Teiler von $a$ und $b$ ist gleich der Menge der gemeinsamen Teiler von $a-b$ und $b$. \\Da die Mengen gleich sind, haben sie auch das gleiche Minimum.\\\begin{quote}
	$\therefore$ \textit{g.g.T.}$(a,b)$ = \textit{g.g.T.}$(a-b,b)$
	\end{quote}
Zudem liefert uns \textit{g.g.T.}$(a,a)$ = $a$ die Korrektheit.
\end{frame}
\begin{frame}
	\frametitle{\textsc{LangsamEuklid}}
	\framesubtitle{Verbesserungsvorschl\"age}
	Dieser Algorithmus endet zwar immer mit der richtigen L\"osung, aber er ist immerhin verbesserungsw\"urdig.
	\begin{itemize}
	\item Wenn eine Zahl sehr gro{\ss} ist, dann subtrahiert man die zweite Zahl mehrmals von der ersten ab.
	\item z.B. $(1069,2) \rightarrow (1067,2) \rightarrow \dots (3,2) \rightarrow (1,2) \rightarrow (1,1)$
	\item Hier braucht man nicht \"uberpr\"ufen welche der beiden Zahlen gr\"o{\ss}er ist.
	\end{itemize}
	Diese Idee hat man implementiert und so ergibt sich der moderne euklidische Algorithmus.
\end{frame}

\subsection{\textsc{Euklid}}
\begin{frame}
	\frametitle{\textsc{Euklid}}

\underline{\textsc{Euklid}}
	\begin{algorithmic}[1]
		\State \textbf{if} $a < b$: vertausche a und b.
		\While {$b>0$}
		\State berechne $q,r$ mit $a=q\cdot b+r$, wobei $0\leq r < b$
		\State $a\gets b, b\gets r$
		\EndWhile
		\State \textbf{return} $a$
	\end{algorithmic}	
	
\end{frame}
\begin{frame}
	\frametitle{\textsc{Euklid}}

	\begin{figure}
	\centering
	\begin{tikzpicture}
\draw [thick, ->] (1,2.5) -- (1,1.5);
\draw (0,1.5) -- (0,0) -- (2,0) -- (2,1.5) -- (0,1.5);
\node  [above] at (1,0.75) {\tiny{if $a< b$}};
\node  [below] at (1,0.75) {\tiny{dann vertauschen}};

\draw [->](2,0.75) -- (4,0.75);

\draw (4,1.25) -- (4,0.25) -- (6,0.25) -- (6,1.25) -- (4,1.25);
\node at (5,0.75) {\tiny{$b>0?$}};

\draw [->] (6,0.75) -- (8,0.75);

\node [above] at (7,0.75) {\tiny{Ja}};

\draw (8,1.5) -- (8,0) -- (10,0) -- (10,1.5) -- (8,1.5);
\node at (9,1.15) {\tiny{$a=q\cdot b+r$}};
\node at (9,0.75) {\tiny{$0 \leq r < b$}};
\node at (9,0.35) {\tiny{$a\gets b, b\gets r$}};

\draw (9,0) -- (9,-1) -- (5,-1);
\draw [->] (5,-1) -- (5,0.25);

\draw [->] (5,1.25) -- (5,2.75);
\node [right] at (5,2) {\tiny{Nein}};

\draw (4,4) -- (4,2.75) -- (6,2.75) -- (6,4) -- (4,4);
\draw (4.1,3.9) -- (4.1,2.85) -- (5.9,2.85) -- (5.9,3.9) -- (4.1,3.9);
\node at (5,3.375) {\tiny{return $a$}};

\end{tikzpicture}
\caption{Flussdiagramm \textsc{Euklid}}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{\textsc{Euklid}}
\framesubtitle{Endlichkeit}
In jeder Iteration gilt nach Schritt 3 des Algorithmus stets $0 \leq r < b$.
\vspace{5pt}
\\Wenn $r=0$ gilt, dann endet der Algorithmus. \\Aber wenn $r \neq 0$, dann sinkt der Wert von $b$ nach Schritt 4 in dieser Iteration, und der Algorithmus wird weiter ausgef\"uhrt. \\Diese Folge von positiven streng monoton fallenden Werten von $b$ muss terminieren. \\D.h. nach endlich vielen Iterationen muss $r=0$ sein, und dann terminiert der Algorithmus.
\end{frame}

\begin{frame}
	\frametitle{\textsc{Euklid}}
	\framesubtitle{Korrektheit}
	Analog zum \textsc{LangsamEuklid} Algorithmus gilt die Gleichheit der Mengen der gemeinsamen Teiler von $(a,b)$ und $(a - q \cdot b, b)$.
	$\Rightarrow$ \textit{g.g.T.}$(a,b)$ = \textit{g.g.T.}$(a-q\cdot b, b)$
\end{frame}


\section{Laufzeitanalyse}
\begin{frame}
	\frametitle{Laufzeitanalyse}
	\begin{itemize}
	\item Sei $T_{b}$ die durchschnittliche Anzahl an Iterationen des euklidischen Algorithmus, wenn der Parameter $b$ festliegt \"uber alle $a \in \mathbb{N}$.
	\item Nach der ersten Iteration ist immer nur der Divisionsrest relevant. Deswegen m\"usste $T_{b}$ f\"ur alle $b \in \mathbb{N}$ existieren und l\"asst sich als Durchschnitt \"uber die Anzahl an Iterationen bei $a=1, a=2, \dots ,a=b$ berechnen.
	\item Beispiel. Im Durchschnitt muss man 2.6 Iterationen ausf\"uhren wenn man eine nat\"urliche Zahl auf Teilerfremdheit mit 5 \"uberpr\"ufen will, denn $T_5 = \frac{2+3+4+3+1}{5} = 2.6$.
	\end{itemize}
	\end{frame}
	
	\begin{frame}
	\frametitle{Laufzeitanalyse}
	\begin{itemize}
	\item Sei umgekehrt $U_{a}$ die durchschnittliche Anzahl an Iterationen des euklidischen Algorithmus, wenn der Parameter $a$ festliegt \"uber alle $b \in \mathbb{N}$.
	\item Dann gilt $b \leq a$ nur in endlich vielen F\"allen. Ansonsten werden immer die Zahlen in der ersten Iteration getauscht. Danach ist die Anzahl der Iterationen identisch wie oben. Dann muss $U_a = T_a + 1$ gelten.
	\end{itemize}
	\end{frame}

\end{document}

